#!/usr/bin/env python
# coding: utf-8

# In[ ]:


import telebot
from telebot import types, TeleBot
from elevenlabs import generate,set_api_key
import os
import datetime
from requests.exceptions import ConnectionError, Timeout, RequestException
import sqlite3
from ratelimiter import RateLimiter
from aiogram.types.message import ContentType
from yookassa import Payment, Configuration
from telegram import Update
from telegram.ext import Updater, CallbackContext
from telebot.types import LabeledPrice, ShippingOption
from dotenv import load_dotenv

from database import update_user_consent,create_table,add_columns_if_not_exist,get_db_connection,update_user_counter,user_exists,insert_user_data,update_user_voice,get_user_voice,get_user_counter


length = 200
load_dotenv("api.env")  # Load the API keys from the api.env file
TOKEN  = os.environ.get("TOKEN")
provider_token = os.environ.get("provider_token")
set_api_key(os.environ.get("set_api_key"))

# set_api_key("ec84cc3b7fff66dd2bfa62952ab47f8c")
bot = telebot.TeleBot(TOKEN, threaded=True)
bot.set_webhook()
# Use a dictionary to map the voice name to the corresponding voice ID or parameter for the generate function.


voice_map = { 
    'Eminem': 'Z547UOMXhucvfGKEdF8i',
    'DanReynolds': 'HrkLioveuuWsAdmb6bJP',
    'LexFridman': 'tnI1d5eS1WVybV4wtiwD',
    'TomCruise': 'V2DbRyTMBaYmRyATWCsI',
    'ElonMusk': 'x2Z70Sdz12lAfWLfWfTO',
    'Glinda': 'z9fAnlkpzviPz146aGWa'
}


@bot.message_handler(commands=['start','command1','main'])
def start(message):
    user_id = message.from_user.id
    user_name = message.from_user.first_name  # or .username, based on what you want to store
    chat_id = message.chat.id
    if user_exists(user_id) == False:
        insert_user_data(user_id, user_name, chat_id)
        user_id = message.from_user.id
        counter = 3
        update_user_counter(user_id, counter)
        
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    btn1 = types.KeyboardButton('generate')
    markup.row(btn1)
    bot.send_message(
        message.chat.id,
        f'Hi, {message.from_user.first_name}, I can convert text to audio with different voices Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø',
        reply_markup=markup)
    #     bot.send_message(message.chat.id, f'–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name},–Ø –º–æ–≥—É –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –≤ –∞—É–¥–∏–æ Û†ÅßÛ†Å¢üá∑üá∫', reply_markup=markup)
    bot.register_next_step_handler(message, on_click)


def on_click(message):
    if message.text == 'generate':
        user_id = message.from_user.id
        counter = get_user_counter(user_id)
        counter = counter if counter is not None else 0
        if counter <= 0:
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            btn1 = types.KeyboardButton('payment')
            markup.row(btn1)
            bot.send_message(
                message.chat.id,
                "You have reached the limit of free attempts. Please consider the paid option for creating new audios. The cost of an additional 10 audios is $1.",
                reply_markup=markup)
            bot.register_next_step_handler(message, payment)
        else:
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            btn1 = types.KeyboardButton('yes')
            btn2 = types.KeyboardButton('no')
            markup.row(btn1, btn2)
            bot.send_message(message.chat.id, 'I hereby confirm that I will not use the content generated by the platform for any illegal, fraudulent or malicious purposes.', reply_markup=markup)
            bot.register_next_step_handler(message, on_click_permission)


def on_click_permission(message):
    if message.text == 'yes':
        chose_option(message)
        update_user_consent(message.from_user.id, 'yes')
    elif message.text == 'no':
        update_user_consent(message.from_user.id, 'no')
        start(message)


@bot.message_handler(commands=['generate', 'change'])
def chose_option(message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    btn1 = types.KeyboardButton('music')
    btn2 = types.KeyboardButton('technology')
    btn3 = types.KeyboardButton('politics')
    btn4 = types.KeyboardButton('media')
    btn5 = types.KeyboardButton('science')
    btn6 = types.KeyboardButton('sport')
    markup.row(btn1, btn2)
    markup.row(btn3, btn4)
    markup.row(btn5, btn6)
    bot.send_message(message.chat.id, 'Select a style:', reply_markup=markup)
    bot.register_next_step_handler(message, chose_voice)


@bot.message_handler(
    commands=['music', 'technology', 'politics', 'media', 'science', 'sport'])
def chose_voice(message):
    if message.text == 'music':
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        btn1 = types.KeyboardButton('Eminem')
        btn2 = types.KeyboardButton('DanReynolds')
        markup.row(btn1, btn2)
        bot.send_message(message.chat.id,
                         'Select a voice:',
                         reply_markup=markup)
        bot.register_next_step_handler(message, send_text)
    elif message.text == 'technology':
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        btn1 = types.KeyboardButton('ElonMusk')
        btn2 = types.KeyboardButton('Steve Jobs')
        markup.row(btn1, btn2)
        bot.send_message(message.chat.id,
                         'Select a voice:',
                         reply_markup=markup)
        bot.register_next_step_handler(message, send_text)


def send_text(message):
    selected_voice = message.text
    user_id = message.from_user.id
    counter = get_user_counter(user_id)

    if selected_voice not in voice_map:
        bot.send_message(message.chat.id,
                         'Invalid voice selection. Please start over.')
        return
    counter = counter if counter is not None else 0
    if counter > 0:
        if selected_voice not in voice_map:
            bot.send_message(message.chat.id,
                             'Invalid voice selection. Please start over.')
            return
        update_user_voice(user_id, selected_voice)
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        btn1 = types.KeyboardButton('main')
        btn2 = types.KeyboardButton('change')
        markup.row(btn1, btn2)
        bot.send_message(
            message.chat.id,
            f"You're now {selected_voice}.Be careful, maximum length of the text has to be less than {length} symbols. Send me some text.",reply_markup=markup)
    elif counter <= 0:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        btn1 = types.KeyboardButton('main')
        btn2 = types.KeyboardButton('payment')
        markup.row(btn1, btn2)
        bot.send_message(
            message.chat.id,
            "You have reached the limit of free attempts. Please consider the paid option for creating new audios. The cost of an additional 20 audios is $1.",
            reply_markup=markup)
        bot.register_next_step_handler(message, payment)





def check_text_length(message, selected_voice):
    
    if selected_voice not in voice_map:
        bot.send_message(message.chat.id,
                         'Invalid voice selection. Please start over.')
        return
    
    elif len(message.text) > length:
        bot.send_message(
            message.chat.id,
            f"Your text is too long. Please make it shorter. The maximum amount of symbols is {length}."
        )
        bot.register_next_step_handler(
            message, check_text_length, selected_voice
        )  # Re-register the same function to check the text again
    else:
        audio_generation(message, selected_voice)


def convert_wav_to_ogg(input_file, output_file):
    cmd = f"ffmpeg -i {input_file} -c:a libopus {output_file}"
    os.system(cmd)


# def voice_option_markup():
#     markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
#     btn_chose_voice = types.KeyboardButton('change')

#     markup.row(btn_chose_voice)
#     return markup


def process_voice_or_text(message,selected_voice):
    if message.text == 'change':
        chose_option(message)
    if message.text == 'main':
        start(message)

    else:
        audio_generation(message,selected_voice)
        pass



@bot.message_handler(func=lambda message: message.text.lower() in
                     ['generate', 'change', 'main'])
def handle_text(message):
    user_id = message.from_user.id

    if message.text.lower() == 'change':
        chose_option(message)
    elif message.text.lower() == 'main':
        start(message)
#     elif selected_voice:
#         # If it's not one of the commands, assume the user has entered text
#         check_text_length(message, selected_voice)
#     else:
#         pass


@bot.message_handler(func=lambda message: not message.text.startswith('/') and
                     message.text.lower() != 'generate' and message.text.lower(
                     ) != 'change' and message.text.lower() != 'main')
def handle_text(message):
    #     if message.text == 'yes':
    user_id = message.from_user.id

    # Fetch the voice preference from the database
    selected_voice = get_user_voice(user_id)

    if selected_voice:
        check_text_length(message, selected_voice)
    else:
        bot.send_message(
            message.chat.id,
            'Please select a voice first using /generate command.')


rate_limiter = RateLimiter(max_calls=10,
                           period=60)  # e.g., 10 calls per minute


@rate_limiter
def call_audio_generation_service(text):
    # call the external audio generation service here
    pass



prices = [LabeledPrice(label='Get more exciting content', amount=10000)]


# @bot.message_handler(commands=['payment'])
def payment(message):
    bot.send_invoice(
        message.chat.id,  #chat_id
        'Payment',  #title
        'Get more exciting content',  #description
        'test',  #invoice_payload
        provider_token,  #provider_token
        'rub',  #currency
        prices,  #prices
        start_parameter='time-machine-example')


@bot.shipping_query_handler(func=lambda query: True)
def shipping(shipping_query):
    print(shipping_query)
    bot.answer_shipping_query(
        shipping_query.id,
        ok=True,
        shipping_options=shipping_options,
        error_message=
        'Oh, seems like our Dog couriers are having a lunch right now. Try again later!'
    )


@bot.pre_checkout_query_handler(func=lambda query: True)
def checkout(pre_checkout_query):
    bot.answer_pre_checkout_query(
        pre_checkout_query.id,
        ok=True,
        error_message=
        "Aliens tried to steal your card's CVV, but we successfully protected your credentials,"
        " try to pay again in a few minutes, we need a small rest.")


@bot.message_handler(content_types=['successful_payment'])
def got_payment(message):
    bot.send_message(message.chat.id,
                     'Hoooooray! Thanks for payment!'.format(
                         message.successful_payment.total_amount / 100,
                         message.successful_payment.currency))
    user_id = message.from_user.id
    counter = 10
    update_user_counter(user_id, counter)
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
    btn1 = types.KeyboardButton('generate')
    markup.row(btn1)
    bot.send_message(message.chat.id, 'What would you like to do next?', reply_markup=markup)
    bot.register_next_step_handler(message, on_click)

def audio_generation(message, selected_voice):
    user_id = message.from_user.id
    counter = get_user_counter(user_id)
    counter = counter if counter is not None else 0
    if counter > 0:
        try:
            user_text = message.text
            bot.send_message(message.chat.id, "Your request is in the queue and will be processed shortly.")
            audio = generate(text=user_text,
                             voice=voice_map[selected_voice],
                             model='eleven_multilingual_v1')
#         except RateLimitException:
#             bot.send_message(
#                 message.chat.id,
#                 "We're experiencing high demand. Please try again in a few minutes."
#             )
        except ConnectionError:
            bot.send_message(
                message.chat.id,
                "Failed to connect to the audio service. Please check your internet connection and try again."
            )
        except Timeout:
            bot.send_message(
                message.chat.id,
                "The request to the audio service timed out. Please try again."
            )
        except RequestException as error:
            bot.send_message(
                message.chat.id,
                f"An error occurred while requesting the audio service: {error}"
            )
        counter -= 1
        update_user_counter(user_id, counter)

        output_file = f"{selected_voice}.wav"
        with open(output_file, "wb") as f:
            f.write(audio)

        # Convert the .wav to .ogg format
        ogg_output_file = output_file.replace(".wav", ".ogg")
        convert_wav_to_ogg(output_file, ogg_output_file)

        with open(ogg_output_file, "rb") as audio_file:
            bot.send_audio(message.chat.id, audio_file)

        os.remove(output_file)  # Delete the .wav file
        os.remove(ogg_output_file)  # Delete the .ogg file after sending

        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        btn1 = types.KeyboardButton('main')
        btn2 = types.KeyboardButton('change')
        markup.row(btn1, btn2)
        bot.send_message(message.chat.id,
                         "Send more text to convert, or see an option below:",
                         reply_markup=markup)
        bot.register_next_step_handler(message, process_voice_or_text,
                                       selected_voice)
    else:
        markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
        btn1 = types.KeyboardButton('main')
        btn2 = types.KeyboardButton('payments')
        markup.row(btn1, btn2)
        bot.send_message(
            message.chat.id,
            "You have reached the limit of free attempts. Please consider the paid option for creating new audios. The cost of an additional 20 audios is $1.",
            reply_markup=markup)
        bot.register_next_step_handler(message, payment)


if __name__ == "__main__":
    bot.polling(none_stop=True)


# In[ ]:




